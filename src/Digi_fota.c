/*
 * Copyright (c) 2025 IED
 *
 */

/** @file
 *
 * @brief Manages a FUOTA (Firmware Upgrade Over-The-Air) client.
 */

#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/sys/reboot.h>
#include "app_version.h"
#include <zboss_api.h>
#include <dfu/dfu_target.h>
#include <dfu/dfu_target_mcuboot.h>

#include "Digi_profile.h"
#include "zigbee_aps.h"
#include "Digi_fota.h"
#include "OTA_dfu_target.h"
#include "nvram.h"

LOG_MODULE_REGISTER(Digi_fota, LOG_LEVEL_INF);

static enum fuota_state_machine_e fuota_state;     // FUOTA state machine state
static uint64_t time_last_state_transition_ms;     // Time of FUOTA last state transition
static uint64_t time_last_attempt_ms;              // Time of FUOTA last attempt to perform an action
static uint16_t attempt_counter;                   // Number of attempts to perform an action in the FUOTA process
static struct firmware_image_t firmware_image;     // Structure describing firmware image
static uint8_t command_sequence_number;            // Sequence number generated by the client, used in FUOTA commands
static uint32_t file_offset;                       // Address of next fragment of bin file to be written on NVRAM
static uint32_t requested_file_offset;             // Address of next fragment of ota file to be requested from the server
static uint16_t current_firmware_version;          // Major(MSB) Minor(LSB)
static uint32_t interrupted_fuota_firmware_version; // Firmware version of a fuota process that was interrupted by a mcu reset
static uint32_t interrupted_fuota_file_size;        // File size of a fuota process that was interrupted by a mcu reset

/**@brief This function initializes the Digi_fota firmware module
 *
 */
void digi_fota_init(void)
{
    fuota_state = FUOTA_INIT_STATE_ST;
    time_last_state_transition_ms = k_uptime_get();
    time_last_attempt_ms = 0;
    attempt_counter = 0;
    command_sequence_number = 0;
    file_offset = 0;
    requested_file_offset = 0;
    current_firmware_version = APP_VERSION_MAJOR;
    current_firmware_version = (current_firmware_version << 8) + APP_VERSION_MINOR;
    interrupted_fuota_firmware_version = 0;
    interrupted_fuota_file_size = 0;
}

/**@brief This function evaluates if the last received APS frame is a FUOTA command
 *
 * @param[in]   input_data   Pointer to payload of received APS frame
 * @param[in]   size_of_input_data   Payload size
 *
 * @retval True It is a valid FUOTA command and was processed
 * @retval False Otherwise
 */
bool is_a_digi_fota_command(uint8_t* input_data, int16_t size_of_input_data)
{
    bool b_return = false;
    if (input_data[2] == IMAGE_NOTIFY_CMD)
    {
        LOG_INF("Received IMAGE NOTIFY command");
        b_return = process_image_notify_cmd(input_data, size_of_input_data);
    }
    else if (input_data[2] == QUERY_NEXT_IMAGE_RESPONSE_CMD)
    {
        LOG_INF("Received NEXT IMAGE RESPONSE command");
        b_return = process_next_image_response_cmd(input_data, size_of_input_data);
    }
    else if (input_data[2] == IMAGE_BLOCK_RESPONSE_CMD)
    {
        LOG_INF("Received IMAGE BLOCK RESPONSE command");
        b_return = process_image_block_response_cmd(input_data, size_of_input_data);
    }
    else if (input_data[2] == UPGRADE_END_RESPONSE_CMD)
    {
        LOG_INF("Received UPGRADE_END_RESPONSE command");
        b_return = process_upgrade_end_response_cmd(input_data, size_of_input_data);
    }
    else if (input_data[2] == DEFAULT_RESPONSE_CMD)
    {
        LOG_INF("Received DEFAULT_RESPONSE command");
        b_return = process_default_response_cmd(input_data, size_of_input_data);
    }
    else
    {
        LOG_ERR("Received not supported command: %u", input_data[2]);
    }
    if (!b_return) LOG_WRN("Command not processed");
    return b_return;
}

/**@brief This function processes the image notify command
 *
 * @param[in]   input_data   Pointer to buffer containing the command
 * @param[in]   size_of_input_data   buffer size
 *
 * @retval True If the command is accepted and processed
 * @retval False Otherwise
 */
bool process_image_notify_cmd(uint8_t* input_data, int16_t size_of_input_data)
{
    bool b_return = false;
    if (size_of_input_data == IMAGE_NOTIFY_CMD_SIZE)
    {
        if (fuota_state == FUOTA_WAITING_FOR_IMAGE_NOTIFY_ST)
        {
            command_sequence_number = 0;
            digi_fota_switch_state(FUOTA_IMAGE_NOTIFY_RECEIVED_ST);
            b_return = true;
        }
    }
    return b_return;
}

/**@brief This function processes the query next image response  command
 *
 * @param[in]   input_data   Pointer to buffer containing the command
 * @param[in]   size_of_input_data   buffer size
 *
 * @retval True If the command is accepted and processed
 * @retval False Otherwise
 */
bool process_next_image_response_cmd(uint8_t* input_data, int16_t size_of_input_data)
{
    bool b_return = false;
    if ((input_data[3] == FOTA_STATUS_NO_IMAGE_AVAILABLE) || (input_data[3] == FOTA_STATUS_NOT_AUTHORIZED))
    {
        if (fuota_state == FUOTA_WAITING_FOR_NEXT_IMAGE_RESPONSE_ST) // Ignore the command if we were not expecting its reception
        {
            LOG_WRN("The server does not have a valid image for this node");
            digi_fota_switch_state(FUOTA_WAITING_FOR_IMAGE_NOTIFY_ST);
            b_return = true;
        }
    }

    if ((input_data[3] == FOTA_STATUS_SUCCESS) && (size_of_input_data == QUERY_NEXT_IMAGE_RESPONSE_CMD_SIZE))
    {
        if (fuota_state == FUOTA_WAITING_FOR_NEXT_IMAGE_RESPONSE_ST) // Ignore the command if we were not expecting its reception
        {
            uint32_t new_firmware_version = (input_data[11] << 24) | (input_data[10] << 16) | (input_data[9] << 8) | input_data[8];
            uint32_t new_file_size = (input_data[15] << 24) | (input_data[14] << 16) | (input_data[13] << 8) | input_data[12];
            if (current_firmware_version >= 0x100A) // From this firmware version onward, the gateway includes the header size in the file size
            {
                if (new_file_size > DIGI_FILE_HEADER_SIZE)
                {
                    new_file_size = new_file_size - DIGI_FILE_HEADER_SIZE; // Do not consider the bytes of the header.
                }
                else
                {
                    new_file_size = 0;
                }
            }
            if (file_offset > 0) // A firmware upgrade is already in process
            {
                LOG_INF("A firmware upgrade is already in process");
                if ((new_firmware_version == firmware_image.firmware_version) && (new_file_size == firmware_image.file_size)) // Check if it is the same file
                {
                    LOG_INF("It is the same bin file. Continue with the upgrade");
                    command_sequence_number = input_data[1];
                    digi_fota_switch_state(FUOTA_MAKE_NEW_IMAGE_BLOCK_REQUEST_ST);
                }
                else
                {
                    LOG_WRN("It is a different bin file. Cancel previous upgrade and start a new one");
                    file_offset = 0;
                }
            }
            if (file_offset == 0)
            {
                firmware_image.manufacturer_code = (input_data[5] << 8) | input_data[4];
                firmware_image.image_type = (input_data[7] << 8) | input_data[6];
                firmware_image.firmware_version = new_firmware_version;
                firmware_image.file_size = new_file_size;
                command_sequence_number = input_data[1];
                if ((firmware_image.manufacturer_code == DIGI_MANUFACTURER_ID) && (firmware_image.file_size > 0))
                {
                    LOG_INF("It is a valid image for this device");
                    LOG_INF("File size: 0x%08X", firmware_image.file_size);
                    digi_fota_switch_state(FUOTA_NEXT_IMAGE_RESPONDED_ST);
                }
                else
                {
                    LOG_WRN("It is not a valid image for this device");
                    digi_fota_switch_state(FUOTA_WAITING_FOR_IMAGE_NOTIFY_ST);
                }
            }
            b_return = true;
        }
    }
    return b_return;
}

/**@brief This function processes the image block response command
 *
 * @param[in]   input_data   Pointer to buffer containing the command
 * @param[in]   size_of_input_data   buffer size
 *
 * @retval True If the command is accepted and processed
 * @retval False Otherwise
 */
bool process_image_block_response_cmd(uint8_t* input_data, int16_t size_of_input_data)
{
    bool b_return = false;
    if ((input_data[3] == FOTA_STATUS_SUCCESS) &&
        (size_of_input_data <= IMAGE_BLOCK_RESPONSE_CMD_SIZE_MAX) && (size_of_input_data >= IMAGE_BLOCK_RESPONSE_CMD_SIZE_MIN))
    {
        if (fuota_state == FUOTA_WAITING_FOR_IMAGE_BLOCK_RESPONSE_ST) // Ignore the command if we were not expecting its reception
        {
            uint8_t chunk_len = size_of_input_data - IMAGE_BLOCK_RESPONSE_HEADER_SIZE;
            uint32_t block_file_offset = (input_data[15] << 24) | (input_data[14] << 16) | (input_data[13] << 8) | input_data[12];
            uint32_t block_firmware_version = (input_data[11] << 24) | (input_data[10] << 16) | (input_data[9] << 8) | input_data[8];
            command_sequence_number = input_data[1];
            if (block_file_offset == requested_file_offset)  // Ignore the command if the offset is not correct
            {
                if (block_firmware_version == firmware_image.firmware_version) // Ignore the command if FW version is not correct
                {
                    const uint8_t *chunk_data = &input_data[IMAGE_BLOCK_RESPONSE_HEADER_SIZE];  // Remove the header from the received payload
                    int ret = handle_fota_chunk(chunk_data, chunk_len, &file_offset); //Store the chuck in NVRAM and update file_offset
                    if (ret != 0)
                    {
                        LOG_ERR("Received block couldn't be stored in NVRAM: %d", ret);
                    }
                    LOG_INF("Next binary file offset: 0x%08X", file_offset);
                    b_return = true;
                    digi_fota_switch_state(FUOTA_IMAGE_BLOCK_RESPONDED_ST);
                }
            }
        }
    }
    return b_return;
}

/**@brief This function processes the upgrade end response command
 *
 * @param[in]   input_data   Pointer to buffer containing the command
 * @param[in]   size_of_input_data   buffer size
 *
 * @retval True If the command is accepted and processed
 * @retval False Otherwise
 */
bool process_upgrade_end_response_cmd(uint8_t* input_data, int16_t size_of_input_data)
{
    bool b_return = false;
    if (size_of_input_data == UPGRADE_END_RESPONSE_CMD_SIZE)
    {
        LOG_INF("OTA finished successfully, now we can reset the device");
        digi_fota_switch_state(FUOTA_UPGRADE_END_RESPONDED_ST);
        b_return = true;
    }
    return b_return;
}

/**@brief This function processes the fuota default response command
 *
 * @param[in]   input_data   Pointer to buffer containing the command
 * @param[in]   size_of_input_data   buffer size
 *
 * @retval True If the command is accepted and processed
 * @retval False Otherwise
 */
bool process_default_response_cmd(uint8_t* input_data, int16_t size_of_input_data)
{
    bool b_return = false;
    if (size_of_input_data == DEFAULT_RESPONSE_CMD_SIZE)
    {
        LOG_WRN("Received fota command DEFAULT RESPONSE to command %u", input_data[3]);
        b_return = true;
    }
    return b_return;
}

/**@brief This function places in the APS output frame queue a frame containing the query next image request command.
 *
 * @retval True if the frame could be placed in the APS output frame
 * @retval False otherwise
 */
bool digi_fota_send_query_next_image_request_cmd(void)
{
    bool b_return = false;

    if (zigbee_aps_get_output_frame_buffer_free_space())
    {
        uint8_t i;
        aps_output_frame_t element;

        element.dst_addr.addr_short = COORDINATOR_SHORT_ADDRESS;
        element.profile_id = DIGI_PROFILE_ID;
        element.cluster_id = DIGI_FOTA_CLUSTER;
        element.src_endpoint = DIGI_BINARY_VALUE_SOURCE_ENDPOINT;
        element.dst_endpoint = DIGI_BINARY_VALUE_DESTINATION_ENDPOINT;
        i = 0;
        element.payload[i++] = FRAME_CONTROL_FIELD_CLUSTER_SPECIFIC_CLIENT_TO_SERVER;
        element.payload[i++] = command_sequence_number;
        element.payload[i++] = QUERY_NEXT_IMAGE_REQUEST_CMD;
        element.payload[i++] = FIELD_CONTROL_HW_VERSION_NO_PRESENT;
        element.payload[i++] = (uint8_t)(DIGI_MANUFACTURER_ID & 0xFF);
        element.payload[i++] = (uint8_t)(DIGI_MANUFACTURER_ID >> 8);
        element.payload[i++] = (uint8_t)(DIGI_IMAGE_TYPE & 0xFF);
        element.payload[i++] = (uint8_t)(DIGI_IMAGE_TYPE >> 8);
        element.payload[i++] = APP_VERSION_MINOR;
        element.payload[i++] = APP_VERSION_MAJOR;
        element.payload[i++] = 0x00; // TODO: Hardcoded to 0x00. Can be changed?
        element.payload[i++] = 0x01; // TODO: Hardcoded to 0x01. Software compatibility number Can be changed?

        element.payload_size = (zb_uint8_t)i;
        if( enqueue_aps_frame(&element) ) b_return = true;
    }
    return b_return;
}

/**@brief This function places in the APS output frame queue a frame containing the image block request command.
 *
 * @retval True if the frame could be placed in the APS output frame
 * @retval False otherwise
 */
bool digi_fota_send_image_block_request_cmd(void)
{
    bool b_return = false;
    if (current_firmware_version >= 0x100A) // From this firmware version onward, the gateway also sends the metadata of the OTA file (62 bytes)
    {
        requested_file_offset = file_offset + DIGI_FILE_HEADER_SIZE;  // Correct the offset. The first 62 bytes of the file are metadata.
    }
    else
    {
        requested_file_offset = file_offset;
    }

    if (zigbee_aps_get_output_frame_buffer_free_space())
    {
        uint8_t i;
        aps_output_frame_t element;

        element.dst_addr.addr_short = COORDINATOR_SHORT_ADDRESS;
        element.profile_id = DIGI_PROFILE_ID;
        element.cluster_id = DIGI_FOTA_CLUSTER;
        element.src_endpoint = DIGI_BINARY_VALUE_SOURCE_ENDPOINT;
        element.dst_endpoint = DIGI_BINARY_VALUE_DESTINATION_ENDPOINT;
        i = 0;
        element.payload[i++] = FRAME_CONTROL_FIELD_CLUSTER_SPECIFIC_CLIENT_TO_SERVER;
        element.payload[i++] = command_sequence_number +1;
        element.payload[i++] = IMAGE_BLOCK_REQUEST_CMD;
        element.payload[i++] = FOTA_STATUS_SUCCESS;
        element.payload[i++] = (uint8_t)(DIGI_MANUFACTURER_ID & 0xFF);
        element.payload[i++] = (uint8_t)(DIGI_MANUFACTURER_ID >> 8);
        element.payload[i++] = (uint8_t)(DIGI_IMAGE_TYPE & 0xFF);
        element.payload[i++] = (uint8_t)(DIGI_IMAGE_TYPE >> 8);
        element.payload[i++] = (uint8_t)(firmware_image.firmware_version & 0xFF);
        element.payload[i++] = (uint8_t)((firmware_image.firmware_version >> 8) & 0xFF);
        element.payload[i++] = (uint8_t)((firmware_image.firmware_version >> 16) & 0xFF);
        element.payload[i++] = (uint8_t)(firmware_image.firmware_version >> 24);
        element.payload[i++] = (uint8_t)(requested_file_offset & 0xFF); // Low byte of file offset
        element.payload[i++] = (uint8_t)((requested_file_offset >> 8) & 0xFF);
        element.payload[i++] = (uint8_t)((requested_file_offset >> 16) & 0xFF);
        element.payload[i++] = (uint8_t)((requested_file_offset >> 24) & 0xFF); // High byte of file offset
        element.payload[i++] = FILE_BLOCK_MAX_SIZE;
        element.payload_size = (zb_uint8_t)i;

        if( enqueue_aps_frame(&element) ) b_return = true;
    }
    return b_return;
}

/**@brief This function places in the APS output frame queue a frame containing the upgrade end request command.
 *
 * @retval True if the frame could be placed in the APS output frame
 * @retval False otherwise
 */
bool digi_fota_send_upgrade_end_request_cmd(void)
{
    bool b_return = false;

    if (zigbee_aps_get_output_frame_buffer_free_space())
    {
        uint8_t i;
        aps_output_frame_t element;

        element.dst_addr.addr_short = COORDINATOR_SHORT_ADDRESS;
        element.profile_id = DIGI_PROFILE_ID;
        element.cluster_id = DIGI_FOTA_CLUSTER;
        element.src_endpoint = DIGI_BINARY_VALUE_SOURCE_ENDPOINT;
        element.dst_endpoint = DIGI_BINARY_VALUE_DESTINATION_ENDPOINT;
        i = 0;
        element.payload[i++] = FRAME_CONTROL_FIELD_CLUSTER_SPECIFIC_CLIENT_TO_SERVER;
        element.payload[i++] = command_sequence_number + 1;
        element.payload[i++] = UPGRADE_END_REQUEST_CMD;
        element.payload[i++] = FOTA_STATUS_SUCCESS;
        element.payload[i++] = (uint8_t)(DIGI_MANUFACTURER_ID & 0xFF);
        element.payload[i++] = (uint8_t)(DIGI_MANUFACTURER_ID >> 8);
        element.payload[i++] = (uint8_t)(DIGI_IMAGE_TYPE & 0xFF);
        element.payload[i++] = (uint8_t)(DIGI_IMAGE_TYPE >> 8);
        element.payload[i++] = (uint8_t)(firmware_image.firmware_version & 0xFF);
        element.payload[i++] = (uint8_t)((firmware_image.firmware_version >> 8) & 0xFF);
        element.payload[i++] = (uint8_t)((firmware_image.firmware_version >> 16) & 0xFF);
        element.payload[i++] = (uint8_t)(firmware_image.firmware_version >> 24);
        element.payload_size = (zb_uint8_t)i;

        if( enqueue_aps_frame(&element) ) b_return = true;
    }
    return b_return;
}

/**@brief This function implements the state machine that handles the reception of the bin file during a FUOTA.
 *
 */
void digi_fota_manager(void)
{
    uint64_t time_now_ms = k_uptime_get();
    int ret;

    switch(fuota_state)
    {
        case FUOTA_INIT_STATE_ST:
            if (read_from_nvram_if_fota_was_interrupted())
            {
                digi_fota_switch_state(FUOTA_UPGRADE_WAS_INTERRUPTED_ST);
            }
            else
            {
                digi_fota_switch_state(FUOTA_WAITING_FOR_IMAGE_NOTIFY_ST);
            }
            break;
        case FUOTA_UPGRADE_WAS_INTERRUPTED_ST:
            file_offset = OTA_dfu_target_init_resume_previous_upgrade(interrupted_fuota_file_size);
            if (file_offset > 0)
            {
                firmware_image.firmware_version = interrupted_fuota_firmware_version;
                firmware_image.file_size = interrupted_fuota_file_size;
                digi_fota_switch_state(FUOTA_WAITING_FOR_IMAGE_NOTIFY_ST);
            }
            else
            {
                set_in_nvram_fota_is_not_active();
                digi_fota_switch_state(FUOTA_WAITING_FOR_IMAGE_NOTIFY_ST);
            }
            break;
        case FUOTA_WAITING_FOR_IMAGE_NOTIFY_ST:
            break;
        case FUOTA_IMAGE_NOTIFY_RECEIVED_ST:
            digi_fota_switch_state(FUOTA_MAKE_NEXT_IMAGE_REQUEST_ST);
            break;
        case FUOTA_MAKE_NEXT_IMAGE_REQUEST_ST:
            if (digi_fota_send_query_next_image_request_cmd())
            {
                digi_fota_switch_state(FUOTA_WAITING_FOR_NEXT_IMAGE_RESPONSE_ST);
            }
            break;
        case FUOTA_WAITING_FOR_NEXT_IMAGE_RESPONSE_ST:
            if ((time_now_ms - time_last_state_transition_ms) > MAX_NEXT_IMAGE_CMD_RESPONSE_TIME_MS)
            {
                if (attempt_counter < MAX_ATTEMPTS_NEXT_IMAGE_REQUEST)
                {
                    attempt_counter++;
                    digi_fota_switch_state(FUOTA_MAKE_NEXT_IMAGE_REQUEST_ST);
                }
                else
                {
                    attempt_counter = 0;
                    digi_fota_switch_state(FUOTA_WAITING_FOR_IMAGE_NOTIFY_ST);
                    LOG_ERR("The maximum number of attempts to request the next image has been exceeded");
                    if (file_offset > 0)
                    {
                        dfu_target_mcuboot_done(false);
                    }
                }
            }
            break;
        case FUOTA_NEXT_IMAGE_RESPONDED_ST:
            attempt_counter = 0;
            digi_fota_switch_state(FUOTA_INIT_DFU_TARGET);
            set_in_nvram_fota_is_active();
            break;
        case FUOTA_INIT_DFU_TARGET:
            if ((time_now_ms - time_last_attempt_ms) > 2000) // Leave 2 seconds between attempts
            {
                time_last_attempt_ms = time_now_ms;
                ret = OTA_dfu_target_init(firmware_image.file_size);
                if (ret == 0)
                {
                    attempt_counter = 0;
                    LOG_WRN("OTA_dfu_target_init() succeeded");
                    digi_fota_switch_state(FUOTA_MAKE_NEW_IMAGE_BLOCK_REQUEST_ST);
                }
                else
                {
                    attempt_counter++;
                    if (attempt_counter >= MAX_ATTEMPTS_DFU_INIT)
                    {
                        attempt_counter = 0;
                        digi_fota_switch_state(FUOTA_WAITING_FOR_IMAGE_NOTIFY_ST);
                        LOG_ERR("The maximum number of attempts to init the dfu has been exceeded");
                        set_in_nvram_fota_is_not_active();
                    }
                }
            }
            break;
        case FUOTA_MAKE_NEW_IMAGE_BLOCK_REQUEST_ST:
            if ((time_now_ms - time_last_state_transition_ms) > 10) // Artificial delay of 200 ms to avoid network congestion
            {
                if (digi_fota_send_image_block_request_cmd())
                {
                    digi_fota_switch_state(FUOTA_WAITING_FOR_IMAGE_BLOCK_RESPONSE_ST);
                }
            }
            break;
        case FUOTA_WAITING_FOR_IMAGE_BLOCK_RESPONSE_ST:
            if ((time_now_ms - time_last_state_transition_ms) > MAX_IMAGE_BLOCK_CMD_RESPONSE_TIME_MS)
            {
                if (attempt_counter < MAX_ATTEMPTS_IMAGE_BLOCK_REQUEST)
                {
                    attempt_counter++;
                    digi_fota_switch_state(FUOTA_MAKE_NEW_IMAGE_BLOCK_REQUEST_ST);
                }
                else
                {
                    attempt_counter = 0;
                    digi_fota_switch_state(FUOTA_WAITING_FOR_IMAGE_NOTIFY_ST);
                    LOG_ERR("The maximum number of attempts to request an image block has been exceeded");
                }
            }
            break;
        case FUOTA_IMAGE_BLOCK_RESPONDED_ST:
            attempt_counter = 0;
            if (file_offset < firmware_image.file_size)
            {
                digi_fota_switch_state(FUOTA_MAKE_NEW_IMAGE_BLOCK_REQUEST_ST);
            }
            else
            {
                digi_fota_switch_state(FUOTA_MAKE_AN_UPGRADE_END_REQUEST_ST);
            }
            break;
        case FUOTA_MAKE_AN_UPGRADE_END_REQUEST_ST:
            if (digi_fota_send_upgrade_end_request_cmd())
            {
                digi_fota_switch_state(FUOTA_WAITING_FOR_UPGRADE_END_RESPONSE_ST);
            }
            break;
        case FUOTA_WAITING_FOR_UPGRADE_END_RESPONSE_ST:
            if ((time_now_ms - time_last_state_transition_ms) > MAX_UPGRADE_CMD_RESPONSE_TIME_MS)
            {
                if (attempt_counter < MAX_ATTEMPTS_UPGRADE_END_REQUEST)
                {
                    attempt_counter++;
                    digi_fota_switch_state(FUOTA_MAKE_AN_UPGRADE_END_REQUEST_ST);
                }
                else
                {
                    attempt_counter = 0;
                    digi_fota_switch_state(FUOTA_WAITING_FOR_IMAGE_NOTIFY_ST);
                    LOG_ERR("The maximum number of attempts to request an upgrade has been exceeded");
                }
            }
            break;
        case FUOTA_UPGRADE_END_RESPONDED_ST:
            int ret = dfu_target_mcuboot_done(true);
            attempt_counter = 0;
            set_in_nvram_fota_is_not_active();
            if (ret)
            {
                LOG_ERR("dfu done failed: 0x%x\n", ret);
                digi_fota_switch_state(FUOTA_INIT_STATE_ST);
            }
            else
            {
                LOG_WRN("dfu done ok\n");
                dfu_target_mcuboot_schedule_update(0);  // Schedule the update image 0
                sys_reboot(SYS_REBOOT_COLD);
            }
            break;
        default:
            digi_fota_switch_state(FUOTA_INIT_STATE_ST);
            LOG_ERR("FUOTA state machine entered in a no existing state");
            break;
    }
}


/**@brief This function switches the FUOTA state machine to the state passed as argument
 *
 * @param[in]   new_state   New state of FUOTA state machine
 */
void digi_fota_switch_state(enum fuota_state_machine_e new_state)
{
    fuota_state = new_state;
    time_last_state_transition_ms = k_uptime_get();
    time_last_attempt_ms = 0;
}

/**@brief This function stores in NVRAM a flag indicating that there is a FUOTA process running.
 * It also stores the fw version and the size of the bin file.
 *
 */
void set_in_nvram_fota_is_active(void)
{
    int8_t rc;         // Return code from the write operation
    uint8_t upgrade_status = 'A'; //Active
    rc = write_nvram(DUFOTA_STATUS, (void*)&upgrade_status, sizeof(upgrade_status));
    rc = rc + write_nvram(DUFOTA_FW_SIZE,(void*)&firmware_image.file_size, sizeof(firmware_image.file_size));
    rc = rc + write_nvram(DUFOTA_FW_VERSION, (void*)&firmware_image.firmware_version, sizeof(firmware_image.firmware_version));
}

/**@brief This function stores in NVRAM a flag indicating that there is not a FUOTA process running
 *
 */
void set_in_nvram_fota_is_not_active(void)
{
    uint8_t upgrade_status = 0; //No active
    firmware_image.file_size = 0;
    firmware_image.firmware_version = 0;
    write_nvram(DUFOTA_STATUS, (void*)&upgrade_status, sizeof(upgrade_status));
    write_nvram(DUFOTA_FW_SIZE,(void*)&firmware_image.file_size, sizeof(firmware_image.file_size));
    write_nvram(DUFOTA_FW_VERSION, (void*)&firmware_image.firmware_version, sizeof(firmware_image.firmware_version));
}

/**@brief This function checks if there was FUOTA process running before the last reset
 *
 * This function reads from NVRAM the flag indicating if there was a FUOTA process running before the last reset.In that case, it reads the FW version and FW file size.
 *
 *
 * @return Boolean indicating if there was a running FUOTA process before the last reset.
 */
bool read_from_nvram_if_fota_was_interrupted(void)
{
    bool b_return = false;
    uint8_t upgrade_status = 0;
    int8_t rc;

    rc = read_nvram(DUFOTA_STATUS, (void*)&upgrade_status, sizeof(upgrade_status));
    if (rc == 1)
    {
        rc = read_nvram(DUFOTA_FW_SIZE, (void*)&interrupted_fuota_file_size, sizeof(interrupted_fuota_file_size));
        if (rc == 4)
        {
            rc = read_nvram(DUFOTA_FW_VERSION, (void*)&interrupted_fuota_firmware_version, sizeof(interrupted_fuota_firmware_version));
            if (rc == 4)
            {
                if ((upgrade_status == 'A') &&
                    (interrupted_fuota_file_size > 0) && (interrupted_fuota_firmware_version > 0))
                {
                    LOG_WRN("There was an interrupted fw upgrade process");
                    LOG_WRN("Bin file size 0x%08X bytes", interrupted_fuota_file_size);
                    LOG_WRN("FW version: 0x%08X bytes", interrupted_fuota_firmware_version);
                    b_return = true;
                }
                else
                {
                    LOG_INF("There was not an interrupted fw upgrade process");
                }
            }
            else
            {
                LOG_ERR("No pude leer la version de FW");
            }
        }
        else
        {
            LOG_ERR("No pude leer el tama√±o de archivo");
        }
    }
    else
    {
        LOG_ERR("No pude leer el status del FUOTA");
    }

    if(!b_return)
    {
        interrupted_fuota_file_size = 0;
        interrupted_fuota_firmware_version = 0;
    }

    return b_return;
}